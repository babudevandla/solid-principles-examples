# solid-principles-examples
 
**SOLID Introduction**

In Java, **SOLID principles** are an object-oriented approach that are applied to software structure design. It is conceptualized by **Robert C. Martin** (also known as Uncle Bob). These five principles have changed the world of object-oriented programming, and also changed the way of writing software. It also ensures that the software is modular, easy to understand, debug, and refactor. In this section, we will discuss **SOLID principles in Java** with proper example.

**SOLID Acronym**

S : Single Responsibility Principle (SRP)

O : Open closed Principle (OSP)

L : Liskov substitution Principle (LSP)

I : Interface Segregation Principle (ISP)

D : Dependency Inversion Principle (DIP)

Now let’s deep dive into what all SOLID principle we have with Example

**SOLID design principles**

**Single Responsibility Principle**

      This principle states that “a class should have only one reason to change” which means every class should have a single responsibility or single job or single purpose

**Open closed Principle (OSP)**

      This principle states that “software entities (classes, modules, functions, etc.) should be open for extension, 
      but closed for modification” which means you should be able to extend a class behavior, without modifying it.
   
**Liskov substitution Principle (LSP)**

       This principle states that “Derived or child classes must be substitutable for their base or parent classes”. 
       In other words, if class A is a subtype of class B, then we should be able to replace B with A without interrupting the behavior of the program.
   
**Interface Segregation Principle (ISP)**

       This principle is the first principle that applies to Interfaces instead of classes in SOLID and it is similar to the single responsibility principle.
       It states that “do not force any client to implement an interface which is irrelevant to them“.
   
**Dependency Inversion Principle (DIP)**

      The principle states that we must use abstraction (abstract classes and interfaces) instead of concrete implementations. 
      High-level modules should not depend on the low-level module but both should depend on the abstraction
   
